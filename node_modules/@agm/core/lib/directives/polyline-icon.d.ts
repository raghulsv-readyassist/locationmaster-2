/// <reference types="googlemaps" />
import { OnInit } from '@angular/core';
/**
 * AgmPolylineIcon enables to add polyline sequences to add arrows, circle,
 * or custom icons either along the entire line, or in a specific part of it.
 * See https://developers.google.com/maps/documentation/javascript/shapes#polyline_customize
 *
 * ### Example
 * ```html
 *    <agm-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
 *      <agm-polyline>
 *          <agm-icon-sequence [fixedRotation]="true" [path]="'FORWARD_OPEN_ARROW'">
 *          </agm-icon-sequence>
 *      </agm-polyline>
 *    </agm-map>
 * ```
 */
import * as ɵngcc0 from '@angular/core';
export declare class AgmPolylineIcon implements OnInit {
    /**
     * If `true`, each icon in the sequence has the same fixed rotation regardless of the
     * angle of the edge on which it lies. Defaults to `false`, in which case each icon
     * in the sequence is rotated to align with its edge.
     */
    fixedRotation: boolean;
    /**
     * The distance from the start of the line at which an icon is to be rendered. This
     * distance may be expressed as a percentage of line's length (e.g. '50%') or in pixels
     * (e.g. '50px'). Defaults to '100%'.
     */
    offset: string;
    /**
     * The distance between consecutive icons on the line. This distance may be expressed as
     * a percentage of the line's length (e.g. '50%') or in pixels (e.g. '50px'). To disable
     * repeating of the icon, specify '0'. Defaults to '0'.
     */
    repeat: string;
    /**
     * The x coordinate of the position of the symbol relative to the polyline. The coordinate
     * of the symbol's path is translated _left_ by the anchor's x coordinate. By default, a
     * symbol is anchored at (0, 0). The position is expressed in the same coordinate system as the
     * symbol's path.
     */
    anchorX: number;
    /**
     * The y coordinate of the position of the symbol relative to the polyline. The coordinate
     * of the symbol's path is translated _up_ by the anchor's y coordinate. By default, a
     * symbol is anchored at (0, 0). The position is expressed in the same coordinate system as the
     * symbol's path.
     */
    anchorY: number;
    /**
     * The symbol's fill color. All CSS3 colors are supported except for extended named
     * colors. Defaults to the stroke color of the corresponding polyline.
     */
    fillColor: string;
    /**
     * The symbol's fill opacity. Defaults to 0.
     */
    fillOpacity: number;
    /**
     * The symbol's path, which is a built-in symbol path, or a custom path expressed using
     * SVG path notation. Required.
     */
    path: keyof typeof google.maps.SymbolPath | string;
    /**
     * The angle by which to rotate the symbol, expressed clockwise in degrees.
     * Defaults to 0. A symbol where `fixedRotation` is `false` is rotated relative to
     * the angle of the edge on which it lies.
     */
    rotation: number;
    /**
     * The amount by which the symbol is scaled in size. Defaults to the stroke weight
     * of the polyline; after scaling, the symbol must lie inside a square 22 pixels in
     * size centered at the symbol's anchor.
     */
    scale: number;
    /**
     * The symbol's stroke color. All CSS3 colors are supported except for extended named
     * colors. Defaults to the stroke color of the polyline.
     */
    strokeColor: string;
    /**
     * The symbol's stroke opacity. Defaults to the stroke opacity of the polyline.
     */
    strokeOpacity: number;
    /**
     * The symbol's stroke weight. Defaults to the scale of the symbol.
     */
    strokeWeight: number;
    ngOnInit(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmPolylineIcon, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmPolylineIcon, "agm-polyline agm-icon-sequence", never, { "fixedRotation": "fixedRotation"; "offset": "offset"; "repeat": "repeat"; "anchorX": "anchorX"; "anchorY": "anchorY"; "fillColor": "fillColor"; "fillOpacity": "fillOpacity"; "path": "path"; "rotation": "rotation"; "scale": "scale"; "strokeColor": "strokeColor"; "strokeOpacity": "strokeOpacity"; "strokeWeight": "strokeWeight"; }, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9seWxpbmUtaWNvbi5kLnRzIiwic291cmNlcyI6WyJwb2x5bGluZS1pY29uLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cImdvb2dsZW1hcHNcIiAvPlxuaW1wb3J0IHsgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4vKipcbiAqIEFnbVBvbHlsaW5lSWNvbiBlbmFibGVzIHRvIGFkZCBwb2x5bGluZSBzZXF1ZW5jZXMgdG8gYWRkIGFycm93cywgY2lyY2xlLFxuICogb3IgY3VzdG9tIGljb25zIGVpdGhlciBhbG9uZyB0aGUgZW50aXJlIGxpbmUsIG9yIGluIGEgc3BlY2lmaWMgcGFydCBvZiBpdC5cbiAqIFNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9zaGFwZXMjcG9seWxpbmVfY3VzdG9taXplXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqIGBgYGh0bWxcbiAqICAgIDxhZ20tbWFwIFtsYXRpdHVkZV09XCJsYXRcIiBbbG9uZ2l0dWRlXT1cImxuZ1wiIFt6b29tXT1cInpvb21cIj5cbiAqICAgICAgPGFnbS1wb2x5bGluZT5cbiAqICAgICAgICAgIDxhZ20taWNvbi1zZXF1ZW5jZSBbZml4ZWRSb3RhdGlvbl09XCJ0cnVlXCIgW3BhdGhdPVwiJ0ZPUldBUkRfT1BFTl9BUlJPVydcIj5cbiAqICAgICAgICAgIDwvYWdtLWljb24tc2VxdWVuY2U+XG4gKiAgICAgIDwvYWdtLXBvbHlsaW5lPlxuICogICAgPC9hZ20tbWFwPlxuICogYGBgXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEFnbVBvbHlsaW5lSWNvbiBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgLyoqXG4gICAgICogSWYgYHRydWVgLCBlYWNoIGljb24gaW4gdGhlIHNlcXVlbmNlIGhhcyB0aGUgc2FtZSBmaXhlZCByb3RhdGlvbiByZWdhcmRsZXNzIG9mIHRoZVxuICAgICAqIGFuZ2xlIG9mIHRoZSBlZGdlIG9uIHdoaWNoIGl0IGxpZXMuIERlZmF1bHRzIHRvIGBmYWxzZWAsIGluIHdoaWNoIGNhc2UgZWFjaCBpY29uXG4gICAgICogaW4gdGhlIHNlcXVlbmNlIGlzIHJvdGF0ZWQgdG8gYWxpZ24gd2l0aCBpdHMgZWRnZS5cbiAgICAgKi9cbiAgICBmaXhlZFJvdGF0aW9uOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoZSBkaXN0YW5jZSBmcm9tIHRoZSBzdGFydCBvZiB0aGUgbGluZSBhdCB3aGljaCBhbiBpY29uIGlzIHRvIGJlIHJlbmRlcmVkLiBUaGlzXG4gICAgICogZGlzdGFuY2UgbWF5IGJlIGV4cHJlc3NlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgbGluZSdzIGxlbmd0aCAoZS5nLiAnNTAlJykgb3IgaW4gcGl4ZWxzXG4gICAgICogKGUuZy4gJzUwcHgnKS4gRGVmYXVsdHMgdG8gJzEwMCUnLlxuICAgICAqL1xuICAgIG9mZnNldDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIGljb25zIG9uIHRoZSBsaW5lLiBUaGlzIGRpc3RhbmNlIG1heSBiZSBleHByZXNzZWQgYXNcbiAgICAgKiBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGxpbmUncyBsZW5ndGggKGUuZy4gJzUwJScpIG9yIGluIHBpeGVscyAoZS5nLiAnNTBweCcpLiBUbyBkaXNhYmxlXG4gICAgICogcmVwZWF0aW5nIG9mIHRoZSBpY29uLCBzcGVjaWZ5ICcwJy4gRGVmYXVsdHMgdG8gJzAnLlxuICAgICAqL1xuICAgIHJlcGVhdDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvc2l0aW9uIG9mIHRoZSBzeW1ib2wgcmVsYXRpdmUgdG8gdGhlIHBvbHlsaW5lLiBUaGUgY29vcmRpbmF0ZVxuICAgICAqIG9mIHRoZSBzeW1ib2wncyBwYXRoIGlzIHRyYW5zbGF0ZWQgX2xlZnRfIGJ5IHRoZSBhbmNob3IncyB4IGNvb3JkaW5hdGUuIEJ5IGRlZmF1bHQsIGFcbiAgICAgKiBzeW1ib2wgaXMgYW5jaG9yZWQgYXQgKDAsIDApLiBUaGUgcG9zaXRpb24gaXMgZXhwcmVzc2VkIGluIHRoZSBzYW1lIGNvb3JkaW5hdGUgc3lzdGVtIGFzIHRoZVxuICAgICAqIHN5bWJvbCdzIHBhdGguXG4gICAgICovXG4gICAgYW5jaG9yWDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBvc2l0aW9uIG9mIHRoZSBzeW1ib2wgcmVsYXRpdmUgdG8gdGhlIHBvbHlsaW5lLiBUaGUgY29vcmRpbmF0ZVxuICAgICAqIG9mIHRoZSBzeW1ib2wncyBwYXRoIGlzIHRyYW5zbGF0ZWQgX3VwXyBieSB0aGUgYW5jaG9yJ3MgeSBjb29yZGluYXRlLiBCeSBkZWZhdWx0LCBhXG4gICAgICogc3ltYm9sIGlzIGFuY2hvcmVkIGF0ICgwLCAwKS4gVGhlIHBvc2l0aW9uIGlzIGV4cHJlc3NlZCBpbiB0aGUgc2FtZSBjb29yZGluYXRlIHN5c3RlbSBhcyB0aGVcbiAgICAgKiBzeW1ib2wncyBwYXRoLlxuICAgICAqL1xuICAgIGFuY2hvclk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgc3ltYm9sJ3MgZmlsbCBjb2xvci4gQWxsIENTUzMgY29sb3JzIGFyZSBzdXBwb3J0ZWQgZXhjZXB0IGZvciBleHRlbmRlZCBuYW1lZFxuICAgICAqIGNvbG9ycy4gRGVmYXVsdHMgdG8gdGhlIHN0cm9rZSBjb2xvciBvZiB0aGUgY29ycmVzcG9uZGluZyBwb2x5bGluZS5cbiAgICAgKi9cbiAgICBmaWxsQ29sb3I6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgc3ltYm9sJ3MgZmlsbCBvcGFjaXR5LiBEZWZhdWx0cyB0byAwLlxuICAgICAqL1xuICAgIGZpbGxPcGFjaXR5OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIHN5bWJvbCdzIHBhdGgsIHdoaWNoIGlzIGEgYnVpbHQtaW4gc3ltYm9sIHBhdGgsIG9yIGEgY3VzdG9tIHBhdGggZXhwcmVzc2VkIHVzaW5nXG4gICAgICogU1ZHIHBhdGggbm90YXRpb24uIFJlcXVpcmVkLlxuICAgICAqL1xuICAgIHBhdGg6IGtleW9mIHR5cGVvZiBnb29nbGUubWFwcy5TeW1ib2xQYXRoIHwgc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBhbmdsZSBieSB3aGljaCB0byByb3RhdGUgdGhlIHN5bWJvbCwgZXhwcmVzc2VkIGNsb2Nrd2lzZSBpbiBkZWdyZWVzLlxuICAgICAqIERlZmF1bHRzIHRvIDAuIEEgc3ltYm9sIHdoZXJlIGBmaXhlZFJvdGF0aW9uYCBpcyBgZmFsc2VgIGlzIHJvdGF0ZWQgcmVsYXRpdmUgdG9cbiAgICAgKiB0aGUgYW5nbGUgb2YgdGhlIGVkZ2Ugb24gd2hpY2ggaXQgbGllcy5cbiAgICAgKi9cbiAgICByb3RhdGlvbjogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgYnkgd2hpY2ggdGhlIHN5bWJvbCBpcyBzY2FsZWQgaW4gc2l6ZS4gRGVmYXVsdHMgdG8gdGhlIHN0cm9rZSB3ZWlnaHRcbiAgICAgKiBvZiB0aGUgcG9seWxpbmU7IGFmdGVyIHNjYWxpbmcsIHRoZSBzeW1ib2wgbXVzdCBsaWUgaW5zaWRlIGEgc3F1YXJlIDIyIHBpeGVscyBpblxuICAgICAqIHNpemUgY2VudGVyZWQgYXQgdGhlIHN5bWJvbCdzIGFuY2hvci5cbiAgICAgKi9cbiAgICBzY2FsZTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBzeW1ib2wncyBzdHJva2UgY29sb3IuIEFsbCBDU1MzIGNvbG9ycyBhcmUgc3VwcG9ydGVkIGV4Y2VwdCBmb3IgZXh0ZW5kZWQgbmFtZWRcbiAgICAgKiBjb2xvcnMuIERlZmF1bHRzIHRvIHRoZSBzdHJva2UgY29sb3Igb2YgdGhlIHBvbHlsaW5lLlxuICAgICAqL1xuICAgIHN0cm9rZUNvbG9yOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIHN5bWJvbCdzIHN0cm9rZSBvcGFjaXR5LiBEZWZhdWx0cyB0byB0aGUgc3Ryb2tlIG9wYWNpdHkgb2YgdGhlIHBvbHlsaW5lLlxuICAgICAqL1xuICAgIHN0cm9rZU9wYWNpdHk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgc3ltYm9sJ3Mgc3Ryb2tlIHdlaWdodC4gRGVmYXVsdHMgdG8gdGhlIHNjYWxlIG9mIHRoZSBzeW1ib2wuXG4gICAgICovXG4gICAgc3Ryb2tlV2VpZ2h0OiBudW1iZXI7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbn1cbiJdfQ==