/// <reference types="googlemaps" />
import { AfterContentInit, ElementRef, EventEmitter, NgZone, OnChanges, OnDestroy, QueryList, SimpleChanges } from '@angular/core';
import { FitBoundsService } from '../services/fit-bounds';
import { GoogleMapsAPIWrapper } from '../services/google-maps-api-wrapper';
import * as ɵngcc0 from '@angular/core';
export declare type ControlPosition = keyof typeof google.maps.ControlPosition;
export declare abstract class AgmMapControl {
    position: ControlPosition;
    abstract getOptions(): Partial<google.maps.MapOptions>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmMapControl, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmMapControl, never, never, { "position": "position"; }, {}, never>;
}
export declare class AgmFullscreenControl extends AgmMapControl {
    getOptions(): Partial<google.maps.MapOptions>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmFullscreenControl, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmFullscreenControl, "agm-map agm-fullscreen-control", never, {}, {}, never>;
}
export declare class AgmMapTypeControl extends AgmMapControl {
    mapTypeIds: (keyof typeof google.maps.MapTypeId)[];
    style: keyof typeof google.maps.MapTypeControlStyle;
    getOptions(): Partial<google.maps.MapOptions>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmMapTypeControl, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmMapTypeControl, "agm-map agm-map-type-control", never, { "mapTypeIds": "mapTypeIds"; "style": "style"; }, {}, never>;
}
export declare class AgmPanControl extends AgmMapControl {
    getOptions(): Partial<google.maps.MapOptions>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmPanControl, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmPanControl, "agm-map agm-pan-control", never, {}, {}, never>;
}
export declare class AgmRotateControl extends AgmMapControl {
    getOptions(): Partial<google.maps.MapOptions>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmRotateControl, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmRotateControl, "agm-map agm-rotate-control", never, {}, {}, never>;
}
export declare class AgmScaleControl extends AgmMapControl {
    getOptions(): Partial<google.maps.MapOptions>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmScaleControl, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmScaleControl, "agm-map agm-scale-control", never, {}, {}, never>;
}
export declare class AgmStreetViewControl extends AgmMapControl {
    getOptions(): Partial<google.maps.MapOptions>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmStreetViewControl, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmStreetViewControl, "agm-map agm-street-view-control", never, {}, {}, never>;
}
export declare class AgmZoomControl extends AgmMapControl {
    style: keyof typeof google.maps.ZoomControlStyle;
    getOptions(): Partial<google.maps.MapOptions>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmZoomControl, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<AgmZoomControl, "agm-map agm-zoom-control", never, { "style": "style"; }, {}, never>;
}
/**
 * AgmMap renders a Google Map.
 * **Important note**: To be able see a map in the browser, you have to define a height for the
 * element `agm-map`.
 *
 * ### Example
 * ```typescript
 * import { Component } from '@angular/core';
 *
 * @Component({
 *  selector: 'my-map-cmp',
 *  styles: [`
 *    agm-map {
 *      height: 300px;
 *    }
 * `],
 *  template: `
 *    <agm-map [latitude]="lat" [longitude]="lng" [zoom]="zoom">
 *    </agm-map>
 *  `
 * })
 * ```
 */
export declare class AgmMap implements OnChanges, AfterContentInit, OnDestroy {
    private _elem;
    private _mapsWrapper;
    private _platformId;
    protected _fitBoundsService: FitBoundsService;
    private _zone;
    /**
     * The longitude that defines the center of the map.
     */
    longitude: number;
    /**
     * The latitude that defines the center of the map.
     */
    latitude: number;
    /**
     * The zoom level of the map. The default zoom level is 8.
     */
    zoom: number;
    /**
     * The minimal zoom level of the map allowed. When not provided, no restrictions to the zoom level
     * are enforced.
     */
    minZoom: number;
    /**
     * The maximal zoom level of the map allowed. When not provided, no restrictions to the zoom level
     * are enforced.
     */
    maxZoom: number;
    /**
     * The control size for the default map controls. Only governs the controls made by the Maps API itself
     */
    controlSize: number;
    /**
     * Enables/disables if map is draggable.
     */
    draggable: boolean;
    /**
     * Enables/disables zoom and center on double click. Enabled by default.
     */
    disableDoubleClickZoom: boolean;
    /**
     * Enables/disables all default UI of the Google map. Please note: When the map is created, this
     * value cannot get updated.
     */
    disableDefaultUI: boolean;
    /**
     * If false, disables scrollwheel zooming on the map. The scrollwheel is enabled by default.
     */
    scrollwheel: boolean;
    /**
     * Color used for the background of the Map div. This color will be visible when tiles have not
     * yet loaded as the user pans. This option can only be set when the map is initialized.
     */
    backgroundColor: string;
    /**
     * The name or url of the cursor to display when mousing over a draggable map. This property uses
     * the css  * cursor attribute to change the icon. As with the css property, you must specify at
     * least one fallback cursor that is not a URL. For example:
     * [draggableCursor]="'url(http://www.example.com/icon.png), auto;'"
     */
    draggableCursor: string;
    /**
     * The name or url of the cursor to display when the map is being dragged. This property uses the
     * css cursor attribute to change the icon. As with the css property, you must specify at least
     * one fallback cursor that is not a URL. For example:
     * [draggingCursor]="'url(http://www.example.com/icon.png), auto;'"
     */
    draggingCursor: string;
    /**
     * If false, prevents the map from being controlled by the keyboard. Keyboard shortcuts are
     * enabled by default.
     */
    keyboardShortcuts: boolean;
    /**
     * Styles to apply to each of the default map types. Note that for Satellite/Hybrid and Terrain
     * modes, these styles will only apply to labels and geometry.
     */
    styles: google.maps.MapTypeStyle[];
    /**
     * When true and the latitude and/or longitude values changes, the Google Maps panTo method is
     * used to
     * center the map. See: https://developers.google.com/maps/documentation/javascript/reference#Map
     */
    usePanning: boolean;
    /**
     * Sets the viewport to contain the given bounds.
     * If this option to `true`, the bounds get automatically computed from all elements that use the {@link AgmFitBounds} directive.
     */
    fitBounds: google.maps.LatLngBoundsLiteral | google.maps.LatLngBounds | boolean;
    /**
     * Padding amount for the bounds.
     */
    fitBoundsPadding: number | google.maps.Padding;
    /**
     * The map mapTypeId. Defaults to 'roadmap'.
     */
    mapTypeId: keyof typeof google.maps.MapTypeId;
    /**
     * When false, map icons are not clickable. A map icon represents a point of interest,
     * also known as a POI. By default map icons are clickable.
     */
    clickableIcons: boolean;
    /**
     * A map icon represents a point of interest, also known as a POI.
     * When map icons are clickable by default, an info window is displayed.
     * When this property is set to false, the info window will not be shown but the click event
     * will still fire
     */
    showDefaultInfoWindow: boolean;
    /**
     * This setting controls how gestures on the map are handled.
     * Allowed values:
     * - 'cooperative' (Two-finger touch gestures pan and zoom the map. One-finger touch gestures are not handled by the map.)
     * - 'greedy'      (All touch gestures pan or zoom the map.)
     * - 'none'        (The map cannot be panned or zoomed by user gestures.)
     * - 'auto'        [default] (Gesture handling is either cooperative or greedy, depending on whether the page is scrollable or not.
     */
    gestureHandling: google.maps.GestureHandlingOptions;
    /**
     * Controls the automatic switching behavior for the angle of incidence of
     * the map. The only allowed values are 0 and 45. The value 0 causes the map
     * to always use a 0° overhead view regardless of the zoom level and
     * viewport. The value 45 causes the tilt angle to automatically switch to
     * 45 whenever 45° imagery is available for the current zoom level and
     * viewport, and switch back to 0 whenever 45° imagery is not available
     * (this is the default behavior). 45° imagery is only available for
     * satellite and hybrid map types, within some locations, and at some zoom
     * levels. Note: getTilt returns the current tilt angle, not the value
     * specified by this option. Because getTilt and this option refer to
     * different things, do not bind() the tilt property; doing so may yield
     * unpredictable effects. (Default of AGM is 0 (disabled). Enable it with value 45.)
     */
    tilt: number;
    /**
     * Options for restricting the bounds of the map.
     * User cannot pan or zoom away from restricted area.
     */
    restriction: google.maps.MapRestriction;
    /**
     * Map option attributes that can change over time
     */
    private static _mapOptionsAttributes;
    private _observableSubscriptions;
    private _fitBoundsSubscription;
    /**
     * This event emitter gets emitted when the user clicks on the map (but not when they click on a
     * marker or infoWindow).
     */
    mapClick: EventEmitter<google.maps.MouseEvent | google.maps.IconMouseEvent>;
    /**
     * This event emitter gets emitted when the user right-clicks on the map (but not when they click
     * on a marker or infoWindow).
     */
    mapRightClick: EventEmitter<google.maps.MouseEvent>;
    /**
     * This event emitter gets emitted when the user double-clicks on the map (but not when they click
     * on a marker or infoWindow).
     */
    mapDblClick: EventEmitter<google.maps.MouseEvent>;
    /**
     * This event emitter is fired when the map center changes.
     */
    centerChange: EventEmitter<google.maps.LatLngLiteral>;
    /**
     * This event is fired when the viewport bounds have changed.
     */
    boundsChange: EventEmitter<google.maps.LatLngBounds>;
    /**
     * This event is fired when the mapTypeId property changes.
     */
    mapTypeIdChange: EventEmitter<google.maps.MapTypeId>;
    /**
     * This event is fired when the map becomes idle after panning or zooming.
     */
    idle: EventEmitter<void>;
    /**
     * This event is fired when the zoom level has changed.
     */
    zoomChange: EventEmitter<number>;
    /**
     * This event is fired when the google map is fully initialized.
     * You get the google.maps.Map instance as a result of this EventEmitter.
     */
    mapReady: EventEmitter<any>;
    /**
     * This event is fired when the visible tiles have finished loading.
     */
    tilesLoaded: EventEmitter<void>;
    mapControls: QueryList<AgmMapControl>;
    constructor(_elem: ElementRef, _mapsWrapper: GoogleMapsAPIWrapper, _platformId: Object, _fitBoundsService: FitBoundsService, _zone: NgZone);
    /** @internal */
    ngAfterContentInit(): void;
    private _initMapInstance;
    /** @internal */
    ngOnDestroy(): void;
    ngOnChanges(changes: SimpleChanges): void;
    private _updateMapOptionsChanges;
    /**
     * Triggers a resize event on the google map instance.
     * When recenter is true, the of the google map gets called with the current lat/lng values or fitBounds value to recenter the map.
     * Returns a promise that gets resolved after the event was triggered.
     */
    triggerResize(recenter?: boolean): Promise<void>;
    private _updatePosition;
    private _setCenter;
    private _fitBounds;
    private _subscribeToFitBoundsUpdates;
    protected _updateBounds(bounds: google.maps.LatLngBounds | google.maps.LatLngBoundsLiteral, padding?: number | google.maps.Padding): void;
    private _isLatLngBoundsLiteral;
    private _handleMapCenterChange;
    private _handleBoundsChange;
    private _handleMapTypeIdChange;
    private _handleMapZoomChange;
    private _handleIdleEvent;
    private _handleTilesLoadedEvent;
    private _handleMapMouseEvents;
    _handleControlChange(): void;
    _setControls(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<AgmMap, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<AgmMap, "agm-map", never, { "longitude": "longitude"; "latitude": "latitude"; "zoom": "zoom"; "draggable": "mapDraggable"; "disableDoubleClickZoom": "disableDoubleClickZoom"; "disableDefaultUI": "disableDefaultUI"; "scrollwheel": "scrollwheel"; "keyboardShortcuts": "keyboardShortcuts"; "styles": "styles"; "usePanning": "usePanning"; "fitBounds": "fitBounds"; "mapTypeId": "mapTypeId"; "clickableIcons": "clickableIcons"; "showDefaultInfoWindow": "showDefaultInfoWindow"; "gestureHandling": "gestureHandling"; "tilt": "tilt"; "minZoom": "minZoom"; "maxZoom": "maxZoom"; "controlSize": "controlSize"; "backgroundColor": "backgroundColor"; "draggableCursor": "draggableCursor"; "draggingCursor": "draggingCursor"; "fitBoundsPadding": "fitBoundsPadding"; "restriction": "restriction"; }, { "mapClick": "mapClick"; "mapRightClick": "mapRightClick"; "mapDblClick": "mapDblClick"; "centerChange": "centerChange"; "boundsChange": "boundsChange"; "mapTypeIdChange": "mapTypeIdChange"; "idle": "idle"; "zoomChange": "zoomChange"; "mapReady": "mapReady"; "tilesLoaded": "tilesLoaded"; }, ["mapControls"], ["*"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwLmQudHMiLCJzb3VyY2VzIjpbIm1hcC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJnb29nbGVtYXBzXCIgLz5cbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgTmdab25lLCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgUXVlcnlMaXN0LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGaXRCb3VuZHNTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvZml0LWJvdW5kcyc7XG5pbXBvcnQgeyBHb29nbGVNYXBzQVBJV3JhcHBlciB9IGZyb20gJy4uL3NlcnZpY2VzL2dvb2dsZS1tYXBzLWFwaS13cmFwcGVyJztcbmV4cG9ydCBkZWNsYXJlIHR5cGUgQ29udHJvbFBvc2l0aW9uID0ga2V5b2YgdHlwZW9mIGdvb2dsZS5tYXBzLkNvbnRyb2xQb3NpdGlvbjtcbmV4cG9ydCBkZWNsYXJlIGFic3RyYWN0IGNsYXNzIEFnbU1hcENvbnRyb2wge1xuICAgIHBvc2l0aW9uOiBDb250cm9sUG9zaXRpb247XG4gICAgYWJzdHJhY3QgZ2V0T3B0aW9ucygpOiBQYXJ0aWFsPGdvb2dsZS5tYXBzLk1hcE9wdGlvbnM+O1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQWdtRnVsbHNjcmVlbkNvbnRyb2wgZXh0ZW5kcyBBZ21NYXBDb250cm9sIHtcbiAgICBnZXRPcHRpb25zKCk6IFBhcnRpYWw8Z29vZ2xlLm1hcHMuTWFwT3B0aW9ucz47XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBBZ21NYXBUeXBlQ29udHJvbCBleHRlbmRzIEFnbU1hcENvbnRyb2wge1xuICAgIG1hcFR5cGVJZHM6IChrZXlvZiB0eXBlb2YgZ29vZ2xlLm1hcHMuTWFwVHlwZUlkKVtdO1xuICAgIHN0eWxlOiBrZXlvZiB0eXBlb2YgZ29vZ2xlLm1hcHMuTWFwVHlwZUNvbnRyb2xTdHlsZTtcbiAgICBnZXRPcHRpb25zKCk6IFBhcnRpYWw8Z29vZ2xlLm1hcHMuTWFwT3B0aW9ucz47XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBBZ21QYW5Db250cm9sIGV4dGVuZHMgQWdtTWFwQ29udHJvbCB7XG4gICAgZ2V0T3B0aW9ucygpOiBQYXJ0aWFsPGdvb2dsZS5tYXBzLk1hcE9wdGlvbnM+O1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQWdtUm90YXRlQ29udHJvbCBleHRlbmRzIEFnbU1hcENvbnRyb2wge1xuICAgIGdldE9wdGlvbnMoKTogUGFydGlhbDxnb29nbGUubWFwcy5NYXBPcHRpb25zPjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEFnbVNjYWxlQ29udHJvbCBleHRlbmRzIEFnbU1hcENvbnRyb2wge1xuICAgIGdldE9wdGlvbnMoKTogUGFydGlhbDxnb29nbGUubWFwcy5NYXBPcHRpb25zPjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEFnbVN0cmVldFZpZXdDb250cm9sIGV4dGVuZHMgQWdtTWFwQ29udHJvbCB7XG4gICAgZ2V0T3B0aW9ucygpOiBQYXJ0aWFsPGdvb2dsZS5tYXBzLk1hcE9wdGlvbnM+O1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQWdtWm9vbUNvbnRyb2wgZXh0ZW5kcyBBZ21NYXBDb250cm9sIHtcbiAgICBzdHlsZToga2V5b2YgdHlwZW9mIGdvb2dsZS5tYXBzLlpvb21Db250cm9sU3R5bGU7XG4gICAgZ2V0T3B0aW9ucygpOiBQYXJ0aWFsPGdvb2dsZS5tYXBzLk1hcE9wdGlvbnM+O1xufVxuLyoqXG4gKiBBZ21NYXAgcmVuZGVycyBhIEdvb2dsZSBNYXAuXG4gKiAqKkltcG9ydGFudCBub3RlKio6IFRvIGJlIGFibGUgc2VlIGEgbWFwIGluIHRoZSBicm93c2VyLCB5b3UgaGF2ZSB0byBkZWZpbmUgYSBoZWlnaHQgZm9yIHRoZVxuICogZWxlbWVudCBgYWdtLW1hcGAuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktbWFwLWNtcCcsXG4gKiAgc3R5bGVzOiBbYFxuICogICAgYWdtLW1hcCB7XG4gKiAgICAgIGhlaWdodDogMzAwcHg7XG4gKiAgICB9XG4gKiBgXSxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPGFnbS1tYXAgW2xhdGl0dWRlXT1cImxhdFwiIFtsb25naXR1ZGVdPVwibG5nXCIgW3pvb21dPVwiem9vbVwiPlxuICogICAgPC9hZ20tbWFwPlxuICogIGBcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQWdtTWFwIGltcGxlbWVudHMgT25DaGFuZ2VzLCBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgX2VsZW07XG4gICAgcHJpdmF0ZSBfbWFwc1dyYXBwZXI7XG4gICAgcHJpdmF0ZSBfcGxhdGZvcm1JZDtcbiAgICBwcm90ZWN0ZWQgX2ZpdEJvdW5kc1NlcnZpY2U6IEZpdEJvdW5kc1NlcnZpY2U7XG4gICAgcHJpdmF0ZSBfem9uZTtcbiAgICAvKipcbiAgICAgKiBUaGUgbG9uZ2l0dWRlIHRoYXQgZGVmaW5lcyB0aGUgY2VudGVyIG9mIHRoZSBtYXAuXG4gICAgICovXG4gICAgbG9uZ2l0dWRlOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGxhdGl0dWRlIHRoYXQgZGVmaW5lcyB0aGUgY2VudGVyIG9mIHRoZSBtYXAuXG4gICAgICovXG4gICAgbGF0aXR1ZGU6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgem9vbSBsZXZlbCBvZiB0aGUgbWFwLiBUaGUgZGVmYXVsdCB6b29tIGxldmVsIGlzIDguXG4gICAgICovXG4gICAgem9vbTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbWFsIHpvb20gbGV2ZWwgb2YgdGhlIG1hcCBhbGxvd2VkLiBXaGVuIG5vdCBwcm92aWRlZCwgbm8gcmVzdHJpY3Rpb25zIHRvIHRoZSB6b29tIGxldmVsXG4gICAgICogYXJlIGVuZm9yY2VkLlxuICAgICAqL1xuICAgIG1pblpvb206IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW1hbCB6b29tIGxldmVsIG9mIHRoZSBtYXAgYWxsb3dlZC4gV2hlbiBub3QgcHJvdmlkZWQsIG5vIHJlc3RyaWN0aW9ucyB0byB0aGUgem9vbSBsZXZlbFxuICAgICAqIGFyZSBlbmZvcmNlZC5cbiAgICAgKi9cbiAgICBtYXhab29tOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRyb2wgc2l6ZSBmb3IgdGhlIGRlZmF1bHQgbWFwIGNvbnRyb2xzLiBPbmx5IGdvdmVybnMgdGhlIGNvbnRyb2xzIG1hZGUgYnkgdGhlIE1hcHMgQVBJIGl0c2VsZlxuICAgICAqL1xuICAgIGNvbnRyb2xTaXplOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogRW5hYmxlcy9kaXNhYmxlcyBpZiBtYXAgaXMgZHJhZ2dhYmxlLlxuICAgICAqL1xuICAgIGRyYWdnYWJsZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBFbmFibGVzL2Rpc2FibGVzIHpvb20gYW5kIGNlbnRlciBvbiBkb3VibGUgY2xpY2suIEVuYWJsZWQgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBkaXNhYmxlRG91YmxlQ2xpY2tab29tOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMvZGlzYWJsZXMgYWxsIGRlZmF1bHQgVUkgb2YgdGhlIEdvb2dsZSBtYXAuIFBsZWFzZSBub3RlOiBXaGVuIHRoZSBtYXAgaXMgY3JlYXRlZCwgdGhpc1xuICAgICAqIHZhbHVlIGNhbm5vdCBnZXQgdXBkYXRlZC5cbiAgICAgKi9cbiAgICBkaXNhYmxlRGVmYXVsdFVJOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIElmIGZhbHNlLCBkaXNhYmxlcyBzY3JvbGx3aGVlbCB6b29taW5nIG9uIHRoZSBtYXAuIFRoZSBzY3JvbGx3aGVlbCBpcyBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgc2Nyb2xsd2hlZWw6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQ29sb3IgdXNlZCBmb3IgdGhlIGJhY2tncm91bmQgb2YgdGhlIE1hcCBkaXYuIFRoaXMgY29sb3Igd2lsbCBiZSB2aXNpYmxlIHdoZW4gdGlsZXMgaGF2ZSBub3RcbiAgICAgKiB5ZXQgbG9hZGVkIGFzIHRoZSB1c2VyIHBhbnMuIFRoaXMgb3B0aW9uIGNhbiBvbmx5IGJlIHNldCB3aGVuIHRoZSBtYXAgaXMgaW5pdGlhbGl6ZWQuXG4gICAgICovXG4gICAgYmFja2dyb3VuZENvbG9yOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb3IgdXJsIG9mIHRoZSBjdXJzb3IgdG8gZGlzcGxheSB3aGVuIG1vdXNpbmcgb3ZlciBhIGRyYWdnYWJsZSBtYXAuIFRoaXMgcHJvcGVydHkgdXNlc1xuICAgICAqIHRoZSBjc3MgICogY3Vyc29yIGF0dHJpYnV0ZSB0byBjaGFuZ2UgdGhlIGljb24uIEFzIHdpdGggdGhlIGNzcyBwcm9wZXJ0eSwgeW91IG11c3Qgc3BlY2lmeSBhdFxuICAgICAqIGxlYXN0IG9uZSBmYWxsYmFjayBjdXJzb3IgdGhhdCBpcyBub3QgYSBVUkwuIEZvciBleGFtcGxlOlxuICAgICAqIFtkcmFnZ2FibGVDdXJzb3JdPVwiJ3VybChodHRwOi8vd3d3LmV4YW1wbGUuY29tL2ljb24ucG5nKSwgYXV0bzsnXCJcbiAgICAgKi9cbiAgICBkcmFnZ2FibGVDdXJzb3I6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvciB1cmwgb2YgdGhlIGN1cnNvciB0byBkaXNwbGF5IHdoZW4gdGhlIG1hcCBpcyBiZWluZyBkcmFnZ2VkLiBUaGlzIHByb3BlcnR5IHVzZXMgdGhlXG4gICAgICogY3NzIGN1cnNvciBhdHRyaWJ1dGUgdG8gY2hhbmdlIHRoZSBpY29uLiBBcyB3aXRoIHRoZSBjc3MgcHJvcGVydHksIHlvdSBtdXN0IHNwZWNpZnkgYXQgbGVhc3RcbiAgICAgKiBvbmUgZmFsbGJhY2sgY3Vyc29yIHRoYXQgaXMgbm90IGEgVVJMLiBGb3IgZXhhbXBsZTpcbiAgICAgKiBbZHJhZ2dpbmdDdXJzb3JdPVwiJ3VybChodHRwOi8vd3d3LmV4YW1wbGUuY29tL2ljb24ucG5nKSwgYXV0bzsnXCJcbiAgICAgKi9cbiAgICBkcmFnZ2luZ0N1cnNvcjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIElmIGZhbHNlLCBwcmV2ZW50cyB0aGUgbWFwIGZyb20gYmVpbmcgY29udHJvbGxlZCBieSB0aGUga2V5Ym9hcmQuIEtleWJvYXJkIHNob3J0Y3V0cyBhcmVcbiAgICAgKiBlbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAga2V5Ym9hcmRTaG9ydGN1dHM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3R5bGVzIHRvIGFwcGx5IHRvIGVhY2ggb2YgdGhlIGRlZmF1bHQgbWFwIHR5cGVzLiBOb3RlIHRoYXQgZm9yIFNhdGVsbGl0ZS9IeWJyaWQgYW5kIFRlcnJhaW5cbiAgICAgKiBtb2RlcywgdGhlc2Ugc3R5bGVzIHdpbGwgb25seSBhcHBseSB0byBsYWJlbHMgYW5kIGdlb21ldHJ5LlxuICAgICAqL1xuICAgIHN0eWxlczogZ29vZ2xlLm1hcHMuTWFwVHlwZVN0eWxlW107XG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlIGFuZCB0aGUgbGF0aXR1ZGUgYW5kL29yIGxvbmdpdHVkZSB2YWx1ZXMgY2hhbmdlcywgdGhlIEdvb2dsZSBNYXBzIHBhblRvIG1ldGhvZCBpc1xuICAgICAqIHVzZWQgdG9cbiAgICAgKiBjZW50ZXIgdGhlIG1hcC4gU2VlOiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2UjTWFwXG4gICAgICovXG4gICAgdXNlUGFubmluZzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2aWV3cG9ydCB0byBjb250YWluIHRoZSBnaXZlbiBib3VuZHMuXG4gICAgICogSWYgdGhpcyBvcHRpb24gdG8gYHRydWVgLCB0aGUgYm91bmRzIGdldCBhdXRvbWF0aWNhbGx5IGNvbXB1dGVkIGZyb20gYWxsIGVsZW1lbnRzIHRoYXQgdXNlIHRoZSB7QGxpbmsgQWdtRml0Qm91bmRzfSBkaXJlY3RpdmUuXG4gICAgICovXG4gICAgZml0Qm91bmRzOiBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHNMaXRlcmFsIHwgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzIHwgYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBQYWRkaW5nIGFtb3VudCBmb3IgdGhlIGJvdW5kcy5cbiAgICAgKi9cbiAgICBmaXRCb3VuZHNQYWRkaW5nOiBudW1iZXIgfCBnb29nbGUubWFwcy5QYWRkaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXAgbWFwVHlwZUlkLiBEZWZhdWx0cyB0byAncm9hZG1hcCcuXG4gICAgICovXG4gICAgbWFwVHlwZUlkOiBrZXlvZiB0eXBlb2YgZ29vZ2xlLm1hcHMuTWFwVHlwZUlkO1xuICAgIC8qKlxuICAgICAqIFdoZW4gZmFsc2UsIG1hcCBpY29ucyBhcmUgbm90IGNsaWNrYWJsZS4gQSBtYXAgaWNvbiByZXByZXNlbnRzIGEgcG9pbnQgb2YgaW50ZXJlc3QsXG4gICAgICogYWxzbyBrbm93biBhcyBhIFBPSS4gQnkgZGVmYXVsdCBtYXAgaWNvbnMgYXJlIGNsaWNrYWJsZS5cbiAgICAgKi9cbiAgICBjbGlja2FibGVJY29uczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBIG1hcCBpY29uIHJlcHJlc2VudHMgYSBwb2ludCBvZiBpbnRlcmVzdCwgYWxzbyBrbm93biBhcyBhIFBPSS5cbiAgICAgKiBXaGVuIG1hcCBpY29ucyBhcmUgY2xpY2thYmxlIGJ5IGRlZmF1bHQsIGFuIGluZm8gd2luZG93IGlzIGRpc3BsYXllZC5cbiAgICAgKiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgc2V0IHRvIGZhbHNlLCB0aGUgaW5mbyB3aW5kb3cgd2lsbCBub3QgYmUgc2hvd24gYnV0IHRoZSBjbGljayBldmVudFxuICAgICAqIHdpbGwgc3RpbGwgZmlyZVxuICAgICAqL1xuICAgIHNob3dEZWZhdWx0SW5mb1dpbmRvdzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGlzIHNldHRpbmcgY29udHJvbHMgaG93IGdlc3R1cmVzIG9uIHRoZSBtYXAgYXJlIGhhbmRsZWQuXG4gICAgICogQWxsb3dlZCB2YWx1ZXM6XG4gICAgICogLSAnY29vcGVyYXRpdmUnIChUd28tZmluZ2VyIHRvdWNoIGdlc3R1cmVzIHBhbiBhbmQgem9vbSB0aGUgbWFwLiBPbmUtZmluZ2VyIHRvdWNoIGdlc3R1cmVzIGFyZSBub3QgaGFuZGxlZCBieSB0aGUgbWFwLilcbiAgICAgKiAtICdncmVlZHknICAgICAgKEFsbCB0b3VjaCBnZXN0dXJlcyBwYW4gb3Igem9vbSB0aGUgbWFwLilcbiAgICAgKiAtICdub25lJyAgICAgICAgKFRoZSBtYXAgY2Fubm90IGJlIHBhbm5lZCBvciB6b29tZWQgYnkgdXNlciBnZXN0dXJlcy4pXG4gICAgICogLSAnYXV0bycgICAgICAgIFtkZWZhdWx0XSAoR2VzdHVyZSBoYW5kbGluZyBpcyBlaXRoZXIgY29vcGVyYXRpdmUgb3IgZ3JlZWR5LCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgcGFnZSBpcyBzY3JvbGxhYmxlIG9yIG5vdC5cbiAgICAgKi9cbiAgICBnZXN0dXJlSGFuZGxpbmc6IGdvb2dsZS5tYXBzLkdlc3R1cmVIYW5kbGluZ09wdGlvbnM7XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgdGhlIGF1dG9tYXRpYyBzd2l0Y2hpbmcgYmVoYXZpb3IgZm9yIHRoZSBhbmdsZSBvZiBpbmNpZGVuY2Ugb2ZcbiAgICAgKiB0aGUgbWFwLiBUaGUgb25seSBhbGxvd2VkIHZhbHVlcyBhcmUgMCBhbmQgNDUuIFRoZSB2YWx1ZSAwIGNhdXNlcyB0aGUgbWFwXG4gICAgICogdG8gYWx3YXlzIHVzZSBhIDDCsCBvdmVyaGVhZCB2aWV3IHJlZ2FyZGxlc3Mgb2YgdGhlIHpvb20gbGV2ZWwgYW5kXG4gICAgICogdmlld3BvcnQuIFRoZSB2YWx1ZSA0NSBjYXVzZXMgdGhlIHRpbHQgYW5nbGUgdG8gYXV0b21hdGljYWxseSBzd2l0Y2ggdG9cbiAgICAgKiA0NSB3aGVuZXZlciA0NcKwIGltYWdlcnkgaXMgYXZhaWxhYmxlIGZvciB0aGUgY3VycmVudCB6b29tIGxldmVsIGFuZFxuICAgICAqIHZpZXdwb3J0LCBhbmQgc3dpdGNoIGJhY2sgdG8gMCB3aGVuZXZlciA0NcKwIGltYWdlcnkgaXMgbm90IGF2YWlsYWJsZVxuICAgICAqICh0aGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yKS4gNDXCsCBpbWFnZXJ5IGlzIG9ubHkgYXZhaWxhYmxlIGZvclxuICAgICAqIHNhdGVsbGl0ZSBhbmQgaHlicmlkIG1hcCB0eXBlcywgd2l0aGluIHNvbWUgbG9jYXRpb25zLCBhbmQgYXQgc29tZSB6b29tXG4gICAgICogbGV2ZWxzLiBOb3RlOiBnZXRUaWx0IHJldHVybnMgdGhlIGN1cnJlbnQgdGlsdCBhbmdsZSwgbm90IHRoZSB2YWx1ZVxuICAgICAqIHNwZWNpZmllZCBieSB0aGlzIG9wdGlvbi4gQmVjYXVzZSBnZXRUaWx0IGFuZCB0aGlzIG9wdGlvbiByZWZlciB0b1xuICAgICAqIGRpZmZlcmVudCB0aGluZ3MsIGRvIG5vdCBiaW5kKCkgdGhlIHRpbHQgcHJvcGVydHk7IGRvaW5nIHNvIG1heSB5aWVsZFxuICAgICAqIHVucHJlZGljdGFibGUgZWZmZWN0cy4gKERlZmF1bHQgb2YgQUdNIGlzIDAgKGRpc2FibGVkKS4gRW5hYmxlIGl0IHdpdGggdmFsdWUgNDUuKVxuICAgICAqL1xuICAgIHRpbHQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBPcHRpb25zIGZvciByZXN0cmljdGluZyB0aGUgYm91bmRzIG9mIHRoZSBtYXAuXG4gICAgICogVXNlciBjYW5ub3QgcGFuIG9yIHpvb20gYXdheSBmcm9tIHJlc3RyaWN0ZWQgYXJlYS5cbiAgICAgKi9cbiAgICByZXN0cmljdGlvbjogZ29vZ2xlLm1hcHMuTWFwUmVzdHJpY3Rpb247XG4gICAgLyoqXG4gICAgICogTWFwIG9wdGlvbiBhdHRyaWJ1dGVzIHRoYXQgY2FuIGNoYW5nZSBvdmVyIHRpbWVcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBfbWFwT3B0aW9uc0F0dHJpYnV0ZXM7XG4gICAgcHJpdmF0ZSBfb2JzZXJ2YWJsZVN1YnNjcmlwdGlvbnM7XG4gICAgcHJpdmF0ZSBfZml0Qm91bmRzU3Vic2NyaXB0aW9uO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgZW1pdHRlciBnZXRzIGVtaXR0ZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG1hcCAoYnV0IG5vdCB3aGVuIHRoZXkgY2xpY2sgb24gYVxuICAgICAqIG1hcmtlciBvciBpbmZvV2luZG93KS5cbiAgICAgKi9cbiAgICBtYXBDbGljazogRXZlbnRFbWl0dGVyPGdvb2dsZS5tYXBzLk1vdXNlRXZlbnQgfCBnb29nbGUubWFwcy5JY29uTW91c2VFdmVudD47XG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBlbWl0dGVyIGdldHMgZW1pdHRlZCB3aGVuIHRoZSB1c2VyIHJpZ2h0LWNsaWNrcyBvbiB0aGUgbWFwIChidXQgbm90IHdoZW4gdGhleSBjbGlja1xuICAgICAqIG9uIGEgbWFya2VyIG9yIGluZm9XaW5kb3cpLlxuICAgICAqL1xuICAgIG1hcFJpZ2h0Q2xpY2s6IEV2ZW50RW1pdHRlcjxnb29nbGUubWFwcy5Nb3VzZUV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGVtaXR0ZXIgZ2V0cyBlbWl0dGVkIHdoZW4gdGhlIHVzZXIgZG91YmxlLWNsaWNrcyBvbiB0aGUgbWFwIChidXQgbm90IHdoZW4gdGhleSBjbGlja1xuICAgICAqIG9uIGEgbWFya2VyIG9yIGluZm9XaW5kb3cpLlxuICAgICAqL1xuICAgIG1hcERibENsaWNrOiBFdmVudEVtaXR0ZXI8Z29vZ2xlLm1hcHMuTW91c2VFdmVudD47XG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBlbWl0dGVyIGlzIGZpcmVkIHdoZW4gdGhlIG1hcCBjZW50ZXIgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBjZW50ZXJDaGFuZ2U6IEV2ZW50RW1pdHRlcjxnb29nbGUubWFwcy5MYXRMbmdMaXRlcmFsPjtcbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHZpZXdwb3J0IGJvdW5kcyBoYXZlIGNoYW5nZWQuXG4gICAgICovXG4gICAgYm91bmRzQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Z29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzPjtcbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIG1hcFR5cGVJZCBwcm9wZXJ0eSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIG1hcFR5cGVJZENoYW5nZTogRXZlbnRFbWl0dGVyPGdvb2dsZS5tYXBzLk1hcFR5cGVJZD47XG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBtYXAgYmVjb21lcyBpZGxlIGFmdGVyIHBhbm5pbmcgb3Igem9vbWluZy5cbiAgICAgKi9cbiAgICBpZGxlOiBFdmVudEVtaXR0ZXI8dm9pZD47XG4gICAgLyoqXG4gICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSB6b29tIGxldmVsIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIHpvb21DaGFuZ2U6IEV2ZW50RW1pdHRlcjxudW1iZXI+O1xuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgZ29vZ2xlIG1hcCBpcyBmdWxseSBpbml0aWFsaXplZC5cbiAgICAgKiBZb3UgZ2V0IHRoZSBnb29nbGUubWFwcy5NYXAgaW5zdGFuY2UgYXMgYSByZXN1bHQgb2YgdGhpcyBFdmVudEVtaXR0ZXIuXG4gICAgICovXG4gICAgbWFwUmVhZHk6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgdmlzaWJsZSB0aWxlcyBoYXZlIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICovXG4gICAgdGlsZXNMb2FkZWQ6IEV2ZW50RW1pdHRlcjx2b2lkPjtcbiAgICBtYXBDb250cm9sczogUXVlcnlMaXN0PEFnbU1hcENvbnRyb2w+O1xuICAgIGNvbnN0cnVjdG9yKF9lbGVtOiBFbGVtZW50UmVmLCBfbWFwc1dyYXBwZXI6IEdvb2dsZU1hcHNBUElXcmFwcGVyLCBfcGxhdGZvcm1JZDogT2JqZWN0LCBfZml0Qm91bmRzU2VydmljZTogRml0Qm91bmRzU2VydmljZSwgX3pvbmU6IE5nWm9uZSk7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkO1xuICAgIHByaXZhdGUgX2luaXRNYXBJbnN0YW5jZTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZDtcbiAgICBwcml2YXRlIF91cGRhdGVNYXBPcHRpb25zQ2hhbmdlcztcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhIHJlc2l6ZSBldmVudCBvbiB0aGUgZ29vZ2xlIG1hcCBpbnN0YW5jZS5cbiAgICAgKiBXaGVuIHJlY2VudGVyIGlzIHRydWUsIHRoZSBvZiB0aGUgZ29vZ2xlIG1hcCBnZXRzIGNhbGxlZCB3aXRoIHRoZSBjdXJyZW50IGxhdC9sbmcgdmFsdWVzIG9yIGZpdEJvdW5kcyB2YWx1ZSB0byByZWNlbnRlciB0aGUgbWFwLlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgZ2V0cyByZXNvbHZlZCBhZnRlciB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICAgKi9cbiAgICB0cmlnZ2VyUmVzaXplKHJlY2VudGVyPzogYm9vbGVhbik6IFByb21pc2U8dm9pZD47XG4gICAgcHJpdmF0ZSBfdXBkYXRlUG9zaXRpb247XG4gICAgcHJpdmF0ZSBfc2V0Q2VudGVyO1xuICAgIHByaXZhdGUgX2ZpdEJvdW5kcztcbiAgICBwcml2YXRlIF9zdWJzY3JpYmVUb0ZpdEJvdW5kc1VwZGF0ZXM7XG4gICAgcHJvdGVjdGVkIF91cGRhdGVCb3VuZHMoYm91bmRzOiBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMgfCBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHNMaXRlcmFsLCBwYWRkaW5nPzogbnVtYmVyIHwgZ29vZ2xlLm1hcHMuUGFkZGluZyk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBfaXNMYXRMbmdCb3VuZHNMaXRlcmFsO1xuICAgIHByaXZhdGUgX2hhbmRsZU1hcENlbnRlckNoYW5nZTtcbiAgICBwcml2YXRlIF9oYW5kbGVCb3VuZHNDaGFuZ2U7XG4gICAgcHJpdmF0ZSBfaGFuZGxlTWFwVHlwZUlkQ2hhbmdlO1xuICAgIHByaXZhdGUgX2hhbmRsZU1hcFpvb21DaGFuZ2U7XG4gICAgcHJpdmF0ZSBfaGFuZGxlSWRsZUV2ZW50O1xuICAgIHByaXZhdGUgX2hhbmRsZVRpbGVzTG9hZGVkRXZlbnQ7XG4gICAgcHJpdmF0ZSBfaGFuZGxlTWFwTW91c2VFdmVudHM7XG4gICAgX2hhbmRsZUNvbnRyb2xDaGFuZ2UoKTogdm9pZDtcbiAgICBfc2V0Q29udHJvbHMoKTogdm9pZDtcbn1cbiJdfQ==